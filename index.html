<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Neil & Leela Walking Scene</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      background: #1a1a2e;
      height: 100dvh; /* Dynamic viewport height for mobile */
      height: 100vh; /* Fallback for older browsers */
      color: #fff;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    @supports (height: 100dvh) {
      body {
        height: 100dvh;
      }
    }

    /* Header */
    .header {
      padding: 1rem 2rem;
      text-align: center;
      background: rgba(0, 0, 0, 0.3);
      backdrop-filter: blur(10px);
      z-index: 100;
    }

    h1 {
      font-size: 1.75rem;
      background: linear-gradient(90deg, #e94560, #f39c12);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 0.25rem;
    }

    .subtitle {
      color: #a0a0a0;
      font-size: 0.85rem;
    }

    /* Controls */
    .controls {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 2rem;
      padding: 1rem 2rem;
      background: rgba(0, 0, 0, 0.2);
      flex-wrap: wrap;
    }

    .control-group {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .control-group label {
      font-weight: 500;
      color: #e0e0e0;
      font-size: 0.9rem;
    }

    button {
      background: linear-gradient(135deg, #e94560, #c23d51);
      color: white;
      border: none;
      padding: 0.6rem 1.25rem;
      border-radius: 8px;
      font-size: 0.9rem;
      cursor: pointer;
      transition: all 0.2s ease;
      font-weight: 600;
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(233, 69, 96, 0.4);
    }

    button:active {
      transform: translateY(0);
    }

    button.paused {
      background: linear-gradient(135deg, #27ae60, #1e8449);
    }

    button.paused:hover {
      box-shadow: 0 4px 15px rgba(39, 174, 96, 0.4);
    }

    input[type="range"] {
      width: 120px;
      height: 6px;
      border-radius: 3px;
      background: rgba(255, 255, 255, 0.2);
      outline: none;
      -webkit-appearance: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #e94560;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    input[type="range"]::-webkit-slider-thumb:hover {
      transform: scale(1.2);
    }

    .value-display {
      min-width: 50px;
      text-align: center;
      background: rgba(255, 255, 255, 0.1);
      padding: 0.2rem 0.4rem;
      border-radius: 4px;
      font-family: monospace;
      font-size: 0.85rem;
    }

    /* Scene Container - uses flexbox to push ground to bottom */
    .scene-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      min-height: 0; /* Allow shrinking */
    }

    /* Sky - flexible area that expands/contracts */
    .sky {
      flex: 1;
      min-height: 50px;
      background: linear-gradient(
        to bottom,
        #1a1a2e 0%,
        #16213e 40%,
        #0f3460 100%
      );
      position: relative;
      overflow: hidden;
    }

    /* Cloud layers */
    .cloudbox,
    .cloudbox2 {
      --cloud-color: white;
      overflow: hidden;
      filter: url("#fancy-goo");
      -moz-filter: url("#fancy-goo");
      position: absolute;
      top: 0;
      left: -25%;
      bottom: 0;
      width: 150%;
      pointer-events: none;
    }

    .cloudbox span,
    .cloudbox2 span {
      position: absolute;
      display: block;
      width: 200px;
      height: 20px;
      background: var(--cloud-color);
      border-radius: 10px;
      transform-origin: 50% 50%;
      opacity: 0.85;
    }

    /* Hidden SVG for goo filter */
    .hidden-svg {
      position: absolute;
      height: 0;
    }

    /* Ground area - fixed height at bottom */
    .ground-area {
      position: relative;
      height: var(--ground-area-height, 140px); /* Ground height + walking space */
      flex-shrink: 0;
      background: #0f3460; /* Match sky gradient bottom color */
    }

    /* Ground */
    .ground {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: var(--ground-height, 80px);
      background: linear-gradient(
        to bottom,
        #2d5016 0%,
        #1a3a0a 30%,
        #0f2505 100%
      );
      border-top: 3px solid #3d6b1e;
    }

    /* Ground texture (grass blades hint) */
    .ground::before {
      content: '';
      position: absolute;
      top: -5px;
      left: 0;
      right: 0;
      height: 10px;
      background: repeating-linear-gradient(
        90deg,
        transparent 0px,
        transparent 8px,
        #3d6b1e 8px,
        #3d6b1e 10px,
        transparent 10px,
        transparent 20px
      );
      opacity: 0.6;
    }

    /* Walking Stage - where characters walk, above the ground */
    .walking-stage {
      position: absolute;
      bottom: var(--walking-stage-bottom, 60px);
      left: 0;
      right: 0;
      top: 0;
    }

    /* Character sprites */
    .character {
      position: absolute;
      bottom: 0; /* Align by bottom (feet on ground) */
      will-change: transform, left;
    }

    /* Shadow under characters */
    .character::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 110%;
      height: 12px;
      background: radial-gradient(ellipse at center, rgba(0,0,0,0.4) 0%, rgba(0,0,0,0.2) 40%, transparent 70%);
      border-radius: 50%;
      z-index: -1;
    }

    .sprite-neil {
      background-repeat: no-repeat;
      transition: opacity 0.15s ease-out;
    }
    
    .sprite-neil.transitioning {
      opacity: 0.7;
    }

    .sprite-leela {
      background-repeat: no-repeat;
      transition: opacity 0.15s ease-out;
    }
    
    .sprite-leela.transitioning {
      opacity: 0.7;
    }

    /* Leela's shadow is smaller */
    .sprite-leela::after {
      width: 120%;
      height: 8px;
    }

    /* Keyboard hints */
    .keyboard-hints {
      display: flex;
      gap: 1rem;
      justify-content: center;
      padding: 0.5rem;
      background: rgba(0, 0, 0, 0.2);
      font-size: 0.75rem;
      color: #888;
    }

    .keyboard-hint kbd {
      background: rgba(255, 255, 255, 0.15);
      padding: 0.15rem 0.4rem;
      border-radius: 3px;
      margin-right: 0.25rem;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    /* State indicator for debugging - uses separate positioning to avoid flip */
    .state-indicator {
      position: absolute;
      top: -20px;
      left: 50%;
      font-size: 10px;
      background: rgba(0,0,0,0.5);
      padding: 2px 6px;
      border-radius: 3px;
      white-space: nowrap;
      opacity: 0;
      transition: opacity 0.3s;
      pointer-events: none;
    }

    .character:hover .state-indicator {
      opacity: 1;
    }

    /* Screensaver mode - hide UI elements */
    body.screensaver .header,
    body.screensaver .controls,
    body.screensaver .keyboard-hints {
      display: none;
    }

    body.screensaver {
      /* cursor always visible */
    }

    body.screensaver .scene-container {
      height: 100%;
    }

    /* Character entrance animation */
    .character.entering {
      transition: none;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>üêï Neil & Leela Walking Scene</h1>
    <p class="subtitle">Watch them walk back and forth across the screen!</p>
  </div>

  <div class="controls">
    <div class="control-group">
      <button id="playPauseBtn">‚è∏ Pause</button>
    </div>
    <div class="control-group">
      <label for="scaleSlider">Scale:</label>
      <input type="range" id="scaleSlider" min="0.25" max="2" step="0.05" value="0.75">
      <span id="scaleValue" class="value-display">0.75√ó</span>
    </div>
  </div>

  <div class="keyboard-hints">
    <span class="keyboard-hint"><kbd>Space</kbd> Play/Pause</span>
    <span class="keyboard-hint"><kbd>+</kbd><kbd>-</kbd> Adjust Scale</span>
  </div>

  <div class="scene-container">
    <div class="sky">
      <div class="cloudbox2" id="cloudbox2"></div>
      <div class="cloudbox" id="cloudbox"></div>
    </div>
    <div class="ground-area">
      <div class="walking-stage" id="walkingStage">
        <!-- Characters will be added via JavaScript -->
      </div>
      <div class="ground"></div>
    </div>
  </div>

  <!-- GSAP for cloud animations -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

  <script>
    // ============================================
    // SPRITE SHEET SPECIFICATIONS
    // ============================================
    const SPRITES = {
      neil: {
        walk: {
          src: './neil-walk-spritesheet.png',
          cols: 6,
          rows: 6,
          totalFrames: 36,
          frameWidth: 163,
          frameHeight: 268,
          sheetWidth: 978,
          sheetHeight: 1608,
          fps: 10
        },
        idle: {
          src: './neil-idle-spritesheet.png',
          cols: 6,
          rows: 6,
          totalFrames: 36,
          frameWidth: 226,
          frameHeight: 450,
          sheetWidth: 1356,
          sheetHeight: 2700,
          fps: 12
        },
        thinking: {
          src: './neil-thinking-spritesheet.png',
          cols: 6,
          rows: 6,
          totalFrames: 36,
          frameWidth: 213,
          frameHeight: 260,
          sheetWidth: 1278,
          sheetHeight: 1560,
          fps: 10
        }
      },
      leela: {
        walk: {
          src: './leela-walk-spritesheet.png',
          cols: 6,
          rows: 6,
          totalFrames: 36,
          frameWidth: 293,
          frameHeight: 267,
          sheetWidth: 1758,
          sheetHeight: 1602,
          fps: 23
        },
        idle: {
          src: './leela-idle-spritesheet.png',
          cols: 6,
          rows: 6,
          totalFrames: 36,
          frameWidth: 247,
          frameHeight: 260,
          sheetWidth: 1482,
          sheetHeight: 1560,
          fps: 12
        },
        scratch: {
          src: './leela-scratch-spritesheet.png',
          cols: 6,
          rows: 6,
          totalFrames: 36,
          frameWidth: 299,
          frameHeight: 289,
          sheetWidth: 1794,
          sheetHeight: 1734,
          fps: 12
        }
      }
    };

    // Configuration
    const CONFIG = {
      neilSpeed: 80,
      leelaSpeed: 55,
      leelaHeightRatio: 0.4,
      edgePadding: 50,
      referenceScale: 0.75,
      // State machine timing (in milliseconds)
      minWalkTime: 3000,      // Walk at least 3 seconds before potentially stopping
      maxWalkTime: 8000,      // Walk at most 8 seconds before stopping
      minIdleCycles: 3,       // Idle at least 3 full animation cycles
      maxIdleTime: 5000,      // Idle at most 5 seconds
      thinkingChance: 0.35,   // 35% chance to think during idle
      minThinkCycles: 1,      // Think at least 1 full animation cycle
      maxThinkTime: 6000,     // Think at most 6 seconds
      postThinkIdleTime: 800, // Brief idle after thinking before walking
      // Animation speed multipliers (lower = slower)
      idleAnimSpeed: 0.7,     // Idle animation 70% speed
      thinkingAnimSpeed: 0.7, // Thinking animation 70% speed
      // Easing transitions
      slowDownDuration: 800,  // ms to slow down before stopping
      speedUpDuration: 700,   // ms to speed up when starting to walk
      // Position offsets to align different sprites (in pixels at scale 1)
      // Separate values for each direction since sprites may be asymmetric
      spriteOffsets: {
        // When walking RIGHT (direction = 1, sprite flipped)
        right: {
          walk: 0,
          idle: 20,
          thinking: -15
        },
        // When walking LEFT (direction = -1, sprite normal)
        left: {
          walk: 0,
          idle: 20,      // Move right compared to walk
          thinking: -15  // Move left compared to walk
        }
      },
      transitionDuration: 150  // ms for state transition fade
    };

    // Leela-specific configuration (separate from Neil)
    const LEELA_CONFIG = {
      speed: 55,
      // State machine timing (in milliseconds)
      minWalkTime: 4000,
      maxWalkTime: 10000,
      minIdleCycles: 3,
      minIdleTime: 1000,       // Minimum 1 second idle
      maxIdleTime: 5000,
      scratchChance: 0.70,     // 70% chance to scratch during idle
      minScratchCycles: 1,     // At least 1 full cycle (forward + reverse)
      maxScratchTime: 6000,
      postScratchIdleTime: 1000,    // 1 second minimum idle after scratch
      // Easing transitions
      slowDownDuration: 600,
      speedUpDuration: 500,
      // Animation speed multipliers
      idleAnimSpeed: 1.4,
      scratchAnimSpeed: 1.8,
      // Scratch loop: frames 17-36 (indices 16-35) repeat 1-3 times
      scratchLoopStart: 16,   // 0-based index where loop starts
      scratchLoopEnd: 35,     // 0-based index where loop ends
      scratchLoopMinRepeats: 4,
      scratchLoopMaxRepeats: 10,
      // Position offsets (separate for each direction)
      spriteOffsets: {
        right: { walk: 0, idle: -15, scratch: -15 },
        left: { walk: 0, idle: 15, scratch: 15 }
      }
    };

    // ============================================
    // NEIL CHARACTER CLASS (with state machine)
    // ============================================
    class NeilCharacter {
      constructor(stage) {
        this.name = 'neil';
        this.stage = stage;
        
        // State machine
        // States: walking, slowing, idle, thinking, post-think-idle, speeding
        this.state = 'walking';
        this.stateStartTime = 0;
        this.nextStateChangeTime = 0;
        
        // Speed multiplier for easing (1 = full speed, 0 = stopped)
        this.speedMultiplier = 1;
        
        // Current sprite config (starts with walk)
        this.currentSprite = 'walk';
        this.config = SPRITES.neil.walk;
        
        // Animation state
        this.currentFrame = 0;
        this.lastFrameTime = 0;
        this.frameInterval = 1000 / this.config.fps;
        
        // Position state
        this.x = 0;
        this.direction = 1;
        this.speed = CONFIG.neilSpeed;
        
        // Display scale
        this.displayScale = 1;
        this.referenceDisplayScale = null;
        
        // Create DOM element
        this.element = document.createElement('div');
        this.element.className = 'character sprite-neil';
        this.element.style.backgroundImage = `url('${this.config.src}')`;
        
        // State indicator (hover to see)
        this.stateIndicator = document.createElement('div');
        this.stateIndicator.className = 'state-indicator';
        this.element.appendChild(this.stateIndicator);
        
        this.stage.appendChild(this.element);
        
        // Schedule first state change
        this.scheduleNextStateChange(performance.now());
      }

      /**
       * Get random time between min and max
       */
      randomBetween(min, max) {
        return min + Math.random() * (max - min);
      }

      /**
       * Calculate how long one full animation cycle takes for a sprite
       */
      getAnimCycleDuration(spriteName, speedMultiplier = 1) {
        const sprite = SPRITES.neil[spriteName];
        const baseFrameTime = 1000 / sprite.fps;
        const effectiveFrameTime = baseFrameTime / speedMultiplier;
        return effectiveFrameTime * sprite.totalFrames;
      }

      /**
       * Schedule when the next state change should happen
       */
      scheduleNextStateChange(currentTime) {
        this.stateStartTime = currentTime;
        
        switch (this.state) {
          case 'walking':
            this.nextStateChangeTime = currentTime + this.randomBetween(CONFIG.minWalkTime, CONFIG.maxWalkTime);
            break;
          case 'slowing':
            this.nextStateChangeTime = currentTime + CONFIG.slowDownDuration;
            break;
          case 'idle': {
            // Minimum time = at least N full animation cycles
            const cycleDuration = this.getAnimCycleDuration('idle', CONFIG.idleAnimSpeed);
            const minTime = cycleDuration * CONFIG.minIdleCycles;
            this.nextStateChangeTime = currentTime + this.randomBetween(minTime, CONFIG.maxIdleTime);
            break;
          }
          case 'thinking': {
            // Minimum time = at least N full animation cycles
            const cycleDuration = this.getAnimCycleDuration('thinking', CONFIG.thinkingAnimSpeed);
            const minTime = cycleDuration * CONFIG.minThinkCycles;
            this.nextStateChangeTime = currentTime + this.randomBetween(minTime, CONFIG.maxThinkTime);
            break;
          }
          case 'post-think-idle':
            this.nextStateChangeTime = currentTime + CONFIG.postThinkIdleTime;
            break;
          case 'speeding':
            this.nextStateChangeTime = currentTime + CONFIG.speedUpDuration;
            break;
        }
      }

      /**
       * Switch to a different sprite sheet with smooth transition
       */
      switchSprite(spriteName) {
        if (this.currentSprite === spriteName) return;
        
        // Brief opacity dip for smoother transition
        this.element.classList.add('transitioning');
        
        // Switch sprite immediately
        this.currentSprite = spriteName;
        this.config = SPRITES.neil[spriteName];
        this.currentFrame = 0;
        this.frameInterval = 1000 / this.config.fps;
        
        // Update background image
        this.element.style.backgroundImage = `url('${this.config.src}')`;
        
        // Reapply scale with new sprite dimensions
        this.applyScale();
        
        // Remove transitioning class after transition completes
        setTimeout(() => {
          this.element.classList.remove('transitioning');
        }, CONFIG.transitionDuration);
      }

      /**
       * Transition to a new state
       */
      transitionTo(newState, currentTime) {
        this.state = newState;
        this.scheduleNextStateChange(currentTime);
        
        // Switch sprite based on state
        switch (newState) {
          case 'walking':
          case 'slowing':
          case 'speeding':
            this.switchSprite('walk');
            break;
          case 'idle':
          case 'post-think-idle':
            this.switchSprite('idle');
            break;
          case 'thinking':
            this.switchSprite('thinking');
            break;
        }
      }

      /**
       * Check if it's time to change state and do so
       */
      updateStateMachine(currentTime) {
        if (currentTime < this.nextStateChangeTime) return;
        
        switch (this.state) {
          case 'walking':
            // Start slowing down before idle
            this.transitionTo('slowing', currentTime);
            break;
          
          case 'slowing':
            // Finished slowing, now idle
            this.speedMultiplier = 0;
            this.transitionTo('idle', currentTime);
            break;
            
          case 'idle':
            // Either think or start speeding up to walk
            if (Math.random() < CONFIG.thinkingChance) {
              this.transitionTo('thinking', currentTime);
            } else {
              this.transitionTo('speeding', currentTime);
            }
            break;
            
          case 'thinking':
            // Brief idle before walking again
            this.transitionTo('post-think-idle', currentTime);
            break;
            
          case 'post-think-idle':
            // Start speeding up
            this.transitionTo('speeding', currentTime);
            break;
          
          case 'speeding':
            // Finished speeding up, now walking at full speed
            this.speedMultiplier = 1;
            this.transitionTo('walking', currentTime);
            break;
        }
      }

      /**
       * Set display scale
       */
      setScale(scale) {
        if (this.referenceDisplayScale === null) {
          this.referenceDisplayScale = scale;
        }
        this.displayScale = scale;
        this.applyScale();
      }

      /**
       * Apply current scale to element
       * Normalizes all sprites to have the same height as the walk sprite
       */
      applyScale() {
        const baseScale = this.displayScale;
        
        // Target height is based on walk sprite at current scale
        const targetHeight = SPRITES.neil.walk.frameHeight * baseScale;
        
        // Calculate the scale factor needed for current sprite to match target height
        const spriteScale = targetHeight / this.config.frameHeight;
        
        const width = this.config.frameWidth * spriteScale;
        const height = this.config.frameHeight * spriteScale;
        const sheetW = this.config.sheetWidth * spriteScale;
        const sheetH = this.config.sheetHeight * spriteScale;
        
        // Store the actual sprite scale for rendering
        this.actualSpriteScale = spriteScale;
        
        this.element.style.width = `${width}px`;
        this.element.style.height = `${height}px`;
        this.element.style.backgroundSize = `${sheetW}px ${sheetH}px`;
        
        this.render();
      }

      getWidth() {
        return this.config.frameWidth * this.displayScale;
      }

      /**
       * Update animation and position
       */
      update(currentTime, deltaTime, stageWidth) {
        // Update state machine
        this.updateStateMachine(currentTime);
        
        // Update speed multiplier during easing states
        if (this.state === 'slowing') {
          // Ease out: 1 ‚Üí 0 over slowDownDuration
          const elapsed = currentTime - this.stateStartTime;
          const progress = Math.min(1, elapsed / CONFIG.slowDownDuration);
          // Use cubic ease-out curve (smooth deceleration)
          this.speedMultiplier = 1 - this.easeOutCubic(progress);
        } else if (this.state === 'speeding') {
          // Ease in: 0 ‚Üí 1 over speedUpDuration
          const elapsed = currentTime - this.stateStartTime;
          const progress = Math.min(1, elapsed / CONFIG.speedUpDuration);
          // Use cubic ease-in curve (starts very slow, then accelerates)
          this.speedMultiplier = this.easeInCubic(progress);
        }
        
        // Update animation frame (scale frame rate based on state)
        let effectiveFrameInterval = this.frameInterval;
        
        if (this.state === 'slowing' || this.state === 'speeding') {
          // Slow down animation proportionally to movement speed
          // Use a minimum of 0.05 to prevent complete freeze, max interval of 500ms
          const animSpeed = Math.max(0.05, this.speedMultiplier);
          effectiveFrameInterval = Math.min(500, this.frameInterval / animSpeed);
        } else if (this.state === 'idle' || this.state === 'post-think-idle') {
          // Idle animation runs slower
          effectiveFrameInterval = this.frameInterval / CONFIG.idleAnimSpeed;
        } else if (this.state === 'thinking') {
          // Thinking animation runs even slower
          effectiveFrameInterval = this.frameInterval / CONFIG.thinkingAnimSpeed;
        }
        
        if (currentTime - this.lastFrameTime >= effectiveFrameInterval) {
          this.currentFrame = (this.currentFrame + 1) % this.config.totalFrames;
          this.lastFrameTime = currentTime;
        }
        
        // Move when walking, slowing, or speeding (using speedMultiplier)
        if (this.state === 'walking' || this.state === 'slowing' || this.state === 'speeding') {
          const scaleRatio = this.displayScale / this.referenceDisplayScale;
          const movement = (this.speed * this.speedMultiplier * scaleRatio * deltaTime) / 1000;
          this.x += movement * this.direction;
          
          // Boundary check
          const charWidth = this.getWidth();
          const minX = CONFIG.edgePadding;
          const maxX = stageWidth - charWidth - CONFIG.edgePadding;
          
          if (this.x >= maxX) {
            this.x = maxX;
            this.direction = -1;
          } else if (this.x <= minX) {
            this.x = minX;
            this.direction = 1;
          }
        }
      }
      
      /**
       * Easing functions
       */
      easeOutQuad(t) {
        return t * (2 - t);
      }
      
      // Cubic ease-in starts slower than quadratic
      easeInCubic(t) {
        return t * t * t;
      }
      
      // Quartic ease-out for smoother deceleration
      easeOutCubic(t) {
        return 1 - Math.pow(1 - t, 3);
      }

      /**
       * Update animation frame only (for entrance animation)
       */
      updateAnimation(currentTime) {
        if (currentTime - this.lastFrameTime >= this.frameInterval) {
          this.currentFrame = (this.currentFrame + 1) % this.config.totalFrames;
          this.lastFrameTime = currentTime;
        }
      }

      /**
       * Render to DOM
       */
      render() {
        const col = this.currentFrame % this.config.cols;
        const row = Math.floor(this.currentFrame / this.config.cols);
        const scale = this.actualSpriteScale || this.displayScale;
        const bgX = -(col * this.config.frameWidth * scale);
        const bgY = -(row * this.config.frameHeight * scale);
        
        this.element.style.backgroundPosition = `${bgX}px ${bgY}px`;
        
        // Apply position offset based on current sprite and direction
        // Use separate offsets for each direction since sprites may be asymmetric
        const dirKey = this.direction === 1 ? 'right' : 'left';
        const baseOffset = CONFIG.spriteOffsets[dirKey][this.currentSprite] || 0;
        const finalOffset = baseOffset * this.displayScale;
        
        this.element.style.left = `${this.x + finalOffset}px`;
        
        // Flip logic:
        // - Walking/Idle: direction 1 (right) = flip, direction -1 (left) = normal
        // - Thinking: flip based on direction (sprite faces away, so flip logic is same)
        let isFlipped = false;
        if (this.direction === 1) {
          this.element.style.transform = 'scaleX(-1)';
          isFlipped = true;
        } else {
          this.element.style.transform = 'scaleX(1)';
          isFlipped = false;
        }
        
        // Counter-flip the state indicator so text is always readable
        this.stateIndicator.style.transform = isFlipped 
          ? 'translateX(-50%) scaleX(-1)' 
          : 'translateX(-50%)';
        
        this.element.style.zIndex = 10;
        
        // Update state indicator
        this.stateIndicator.textContent = this.state;
      }
    }

    // ============================================
    // LEELA CHARACTER CLASS (with state machine)
    // ============================================
    class LeelaCharacter {
      constructor(stage) {
        this.name = 'leela';
        this.stage = stage;
        
        // State machine
        // States: walking, slowing, idle, scratch, post-scratch-idle, speeding
        this.state = 'walking';
        this.stateStartTime = 0;
        this.nextStateChangeTime = 0;
        
        // Speed multiplier for easing
        this.speedMultiplier = 1;
        
        // Current sprite config
        this.currentSprite = 'walk';
        this.config = SPRITES.leela.walk;
        
        // Animation state
        this.currentFrame = 0;
        this.lastFrameTime = 0;
        this.frameInterval = 1000 / this.config.fps;
        
        // Ping-pong animation for scratch (forward then reverse)
        this.animDirection = 1; // 1 = forward, -1 = reverse
        this.completedCycles = 0;
        
        // Scratch loop state
        this.scratchLoopRepeats = 0;       // How many times to repeat the loop section
        this.scratchLoopCount = 0;         // Current loop count
        this.inScratchLoop = false;        // Currently in the loop section
        this.scratchReadyToExit = false;   // Flag: time is up, wait for frame 0
        
        // Position state
        this.x = 0;
        this.direction = 1;
        this.speed = LEELA_CONFIG.speed;
        
        // Display scale
        this.displayScale = 1;
        this.referenceDisplayScale = null;
        
        // Create DOM element
        this.element = document.createElement('div');
        this.element.className = 'character sprite-leela';
        this.element.style.backgroundImage = `url('${this.config.src}')`;
        
        // State indicator (hover to see)
        this.stateIndicator = document.createElement('div');
        this.stateIndicator.className = 'state-indicator';
        this.element.appendChild(this.stateIndicator);
        
        this.stage.appendChild(this.element);
        
        // Schedule first state change
        this.scheduleNextStateChange(performance.now());
      }

      randomBetween(min, max) {
        return min + Math.random() * (max - min);
      }

      getAnimCycleDuration(spriteName, speedMultiplier = 1) {
        const sprite = SPRITES.leela[spriteName];
        const baseFrameTime = 1000 / sprite.fps;
        const effectiveFrameTime = baseFrameTime / speedMultiplier;
        // For scratch, one cycle = forward + reverse = 2x frames
        if (spriteName === 'scratch') {
          return effectiveFrameTime * sprite.totalFrames * 2;
        }
        return effectiveFrameTime * sprite.totalFrames;
      }

      scheduleNextStateChange(currentTime) {
        this.stateStartTime = currentTime;
        
        switch (this.state) {
          case 'walking':
            this.nextStateChangeTime = currentTime + this.randomBetween(LEELA_CONFIG.minWalkTime, LEELA_CONFIG.maxWalkTime);
            break;
          case 'slowing':
            this.nextStateChangeTime = currentTime + LEELA_CONFIG.slowDownDuration;
            break;
          case 'idle': {
            const cycleDuration = this.getAnimCycleDuration('idle', LEELA_CONFIG.idleAnimSpeed);
            const minCycleTime = cycleDuration * LEELA_CONFIG.minIdleCycles;
            const minTime = Math.max(minCycleTime, LEELA_CONFIG.minIdleTime);
            this.nextStateChangeTime = currentTime + this.randomBetween(minTime, LEELA_CONFIG.maxIdleTime);
            break;
          }
          case 'scratch': {
            const cycleDuration = this.getAnimCycleDuration('scratch', LEELA_CONFIG.scratchAnimSpeed);
            const minTime = cycleDuration * LEELA_CONFIG.minScratchCycles;
            this.nextStateChangeTime = currentTime + this.randomBetween(minTime, LEELA_CONFIG.maxScratchTime);
            this.scratchReadyToExit = false;
            break;
          }
          case 'post-scratch-idle':
            this.nextStateChangeTime = currentTime + LEELA_CONFIG.postScratchIdleTime;
            break;
          case 'speeding':
            this.nextStateChangeTime = currentTime + LEELA_CONFIG.speedUpDuration;
            break;
        }
      }

      switchSprite(spriteName) {
        if (this.currentSprite === spriteName) return;
        
        this.element.classList.add('transitioning');
        
        this.currentSprite = spriteName;
        this.config = SPRITES.leela[spriteName];
        this.currentFrame = 0;
        this.frameInterval = 1000 / this.config.fps;
        
        // Reset ping-pong state
        this.animDirection = 1;
        this.completedCycles = 0;
        
        // Reset and randomize scratch loop
        if (spriteName === 'scratch') {
          this.scratchLoopRepeats = Math.floor(Math.random() * 
            (LEELA_CONFIG.scratchLoopMaxRepeats - LEELA_CONFIG.scratchLoopMinRepeats + 1)) + 
            LEELA_CONFIG.scratchLoopMinRepeats;
          this.scratchLoopCount = 0;
          this.inScratchLoop = false;
        }
        
        this.element.style.backgroundImage = `url('${this.config.src}')`;
        this.applyScale();
        
        setTimeout(() => {
          this.element.classList.remove('transitioning');
        }, CONFIG.transitionDuration);
      }

      transitionTo(newState, currentTime) {
        this.state = newState;
        this.scheduleNextStateChange(currentTime);
        
        switch (newState) {
          case 'walking':
          case 'slowing':
          case 'speeding':
            this.switchSprite('walk');
            break;
          case 'idle':
          case 'post-scratch-idle':
            this.switchSprite('idle');
            break;
          case 'scratch':
            this.switchSprite('scratch');
            break;
        }
      }

      updateStateMachine(currentTime) {
        if (currentTime < this.nextStateChangeTime) return;
        
        switch (this.state) {
          case 'walking':
            this.transitionTo('slowing', currentTime);
            break;
          case 'slowing':
            this.speedMultiplier = 0;
            this.transitionTo('idle', currentTime);
            break;
          case 'idle':
            if (Math.random() < LEELA_CONFIG.scratchChance) {
              this.transitionTo('scratch', currentTime);
            } else {
              this.transitionTo('speeding', currentTime);
            }
            break;
          case 'scratch':
            // Set flag - wait for animation to reach frame 0
            this.scratchReadyToExit = true;
            break;
          case 'post-scratch-idle':
            this.transitionTo('speeding', currentTime);
            break;
          case 'speeding':
            this.speedMultiplier = 1;
            this.transitionTo('walking', currentTime);
            break;
        }
      }

      setScale(scale) {
        if (this.referenceDisplayScale === null) {
          this.referenceDisplayScale = scale;
        }
        this.displayScale = scale;
        this.applyScale();
      }

      applyScale() {
        const baseScale = this.displayScale;
        const targetHeight = SPRITES.leela.walk.frameHeight * baseScale;
        const spriteScale = targetHeight / this.config.frameHeight;
        
        const width = this.config.frameWidth * spriteScale;
        const height = this.config.frameHeight * spriteScale;
        const sheetW = this.config.sheetWidth * spriteScale;
        const sheetH = this.config.sheetHeight * spriteScale;
        
        this.actualSpriteScale = spriteScale;
        
        this.element.style.width = `${width}px`;
        this.element.style.height = `${height}px`;
        this.element.style.backgroundSize = `${sheetW}px ${sheetH}px`;
        
        this.render();
      }

      getWidth() {
        return this.config.frameWidth * (this.actualSpriteScale || this.displayScale);
      }

      easeOutCubic(t) {
        return 1 - Math.pow(1 - t, 3);
      }

      easeInCubic(t) {
        return t * t * t;
      }

      update(currentTime, deltaTime, stageWidth) {
        this.updateStateMachine(currentTime);
        
        // Update speed multiplier during easing
        if (this.state === 'slowing') {
          const elapsed = currentTime - this.stateStartTime;
          const progress = Math.min(1, elapsed / LEELA_CONFIG.slowDownDuration);
          this.speedMultiplier = 1 - this.easeOutCubic(progress);
        } else if (this.state === 'speeding') {
          const elapsed = currentTime - this.stateStartTime;
          const progress = Math.min(1, elapsed / LEELA_CONFIG.speedUpDuration);
          this.speedMultiplier = this.easeInCubic(progress);
        }
        
        // Update animation frame
        let effectiveFrameInterval = this.frameInterval;
        
        if (this.state === 'slowing' || this.state === 'speeding') {
          const animSpeed = Math.max(0.05, this.speedMultiplier);
          effectiveFrameInterval = Math.min(500, this.frameInterval / animSpeed);
        } else if (this.state === 'idle' || this.state === 'post-scratch-idle') {
          effectiveFrameInterval = this.frameInterval / LEELA_CONFIG.idleAnimSpeed;
        } else if (this.state === 'scratch') {
          effectiveFrameInterval = this.frameInterval / LEELA_CONFIG.scratchAnimSpeed;
        }
        
        if (currentTime - this.lastFrameTime >= effectiveFrameInterval) {
          if (this.state === 'scratch') {
            // Scratch animation with looping section
            // Forward: 0 ‚Üí loopStart, then loop (loopStart ‚Üí loopEnd) N times, then reverse
            
            if (this.animDirection === 1) {
              // Going forward
              this.currentFrame++;
              
              // Check if we've entered or completed the loop section
              if (this.currentFrame >= LEELA_CONFIG.scratchLoopEnd) {
                this.scratchLoopCount++;
                
                if (this.scratchLoopCount < this.scratchLoopRepeats) {
                  // Loop back to start of loop section
                  this.currentFrame = LEELA_CONFIG.scratchLoopStart;
                } else {
                  // Done looping, start reverse
                  this.currentFrame = LEELA_CONFIG.scratchLoopEnd;
                  this.animDirection = -1;
                }
              }
            } else {
              // Going backward (reverse)
              this.currentFrame--;
              
              if (this.currentFrame <= 0) {
                this.currentFrame = 0;
                
                // If ready to exit, transition to post-scratch-idle
                if (this.scratchReadyToExit) {
                  this.transitionTo('post-scratch-idle', currentTime);
                  return; // Stop further processing
                }
                
                this.animDirection = 1;
                this.completedCycles++;
                // Reset loop for next cycle
                this.scratchLoopCount = 0;
                this.scratchLoopRepeats = Math.floor(Math.random() * 
                  (LEELA_CONFIG.scratchLoopMaxRepeats - LEELA_CONFIG.scratchLoopMinRepeats + 1)) + 
                  LEELA_CONFIG.scratchLoopMinRepeats;
              }
            }
          } else {
            // Normal looping animation
            this.currentFrame = (this.currentFrame + 1) % this.config.totalFrames;
          }
          this.lastFrameTime = currentTime;
        }
        
        // Move when walking, slowing, or speeding
        if (this.state === 'walking' || this.state === 'slowing' || this.state === 'speeding') {
          const scaleRatio = this.displayScale / this.referenceDisplayScale;
          const movement = (this.speed * this.speedMultiplier * scaleRatio * deltaTime) / 1000;
          this.x += movement * this.direction;
          
          const charWidth = this.getWidth();
          const minX = CONFIG.edgePadding;
          const maxX = stageWidth - charWidth - CONFIG.edgePadding;
          
          if (this.x >= maxX) {
            this.x = maxX;
            this.direction = -1;
          } else if (this.x <= minX) {
            this.x = minX;
            this.direction = 1;
          }
        }
      }

      /**
       * Update animation frame only (for entrance animation)
       */
      updateAnimation(currentTime) {
        if (currentTime - this.lastFrameTime >= this.frameInterval) {
          this.currentFrame = (this.currentFrame + 1) % this.config.totalFrames;
          this.lastFrameTime = currentTime;
        }
      }

      render() {
        const col = this.currentFrame % this.config.cols;
        const row = Math.floor(this.currentFrame / this.config.cols);
        const scale = this.actualSpriteScale || this.displayScale;
        const bgX = -(col * this.config.frameWidth * scale);
        const bgY = -(row * this.config.frameHeight * scale);
        
        this.element.style.backgroundPosition = `${bgX}px ${bgY}px`;
        
        // Apply position offset
        const dirKey = this.direction === 1 ? 'right' : 'left';
        const baseOffset = LEELA_CONFIG.spriteOffsets[dirKey][this.currentSprite] || 0;
        const finalOffset = baseOffset * this.displayScale;
        
        this.element.style.left = `${this.x + finalOffset}px`;
        
        // Flip based on direction
        let isFlipped = false;
        if (this.direction === 1) {
          this.element.style.transform = 'scaleX(-1)';
          isFlipped = true;
        } else {
          this.element.style.transform = 'scaleX(1)';
          isFlipped = false;
        }
        
        // Counter-flip the state indicator so text is always readable
        this.stateIndicator.style.transform = isFlipped 
          ? 'translateX(-50%) scaleX(-1)' 
          : 'translateX(-50%)';
        
        this.element.style.zIndex = 20;
        
        // Update state indicator
        this.stateIndicator.textContent = this.state;
      }
    }

    // ============================================
    // SCENE MANAGER
    // ============================================
    class WalkingScene {
      constructor() {
        this.stage = document.getElementById('walkingStage');
        this.isPaused = false;
        this.scale = 0.75;
        this.lastTime = 0;
        this.animationId = null;
        
        this.playPauseBtn = document.getElementById('playPauseBtn');
        this.scaleSlider = document.getElementById('scaleSlider');
        this.scaleValue = document.getElementById('scaleValue');
        
        // Create characters
        this.neil = new NeilCharacter(this.stage);
        this.leela = new LeelaCharacter(this.stage);
        
        this.bindEvents();
        this.updateScale(this.scale);
        this.setInitialPositions();
        
        this.animationId = requestAnimationFrame((t) => this.animate(t));
      }

      setInitialPositions() {
        const stageWidth = this.stage.clientWidth || window.innerWidth;
        
        this.neil.x = CONFIG.edgePadding;
        this.neil.direction = 1;
        
        this.leela.x = stageWidth - this.leela.getWidth() - CONFIG.edgePadding;
        this.leela.direction = -1;
      }

      updateScale(newScale) {
        this.scale = newScale;
        this.neil.setScale(newScale);
        
        const neilDisplayHeight = SPRITES.neil.walk.frameHeight * newScale;
        const leelaTargetHeight = neilDisplayHeight * CONFIG.leelaHeightRatio;
        const leelaScale = leelaTargetHeight / SPRITES.leela.walk.frameHeight;
        this.leela.setScale(leelaScale);
      }

      bindEvents() {
        this.playPauseBtn.addEventListener('click', () => this.togglePlayPause());
        
        this.scaleSlider.addEventListener('input', (e) => {
          const newScale = parseFloat(e.target.value);
          this.scaleValue.textContent = `${newScale}√ó`;
          this.updateScale(newScale);
        });
        
        document.addEventListener('keydown', (e) => {
          switch (e.code) {
            case 'Space':
              e.preventDefault();
              this.togglePlayPause();
              break;
            case 'Equal':
            case 'NumpadAdd':
              e.preventDefault();
              this.adjustScale(0.05);
              break;
            case 'Minus':
            case 'NumpadSubtract':
              e.preventDefault();
              this.adjustScale(-0.05);
              break;
          }
        });
        
        window.addEventListener('resize', () => {
          const stageWidth = this.stage.clientWidth;
          const maxX = stageWidth - this.neil.getWidth() - CONFIG.edgePadding;
          if (this.neil.x > maxX) this.neil.x = maxX;
          
          const leelaMaxX = stageWidth - this.leela.getWidth() - CONFIG.edgePadding;
          if (this.leela.x > leelaMaxX) this.leela.x = leelaMaxX;
        });
      }

      togglePlayPause() {
        this.isPaused = !this.isPaused;
        this.playPauseBtn.textContent = this.isPaused ? '‚ñ∂ Play' : '‚è∏ Pause';
        this.playPauseBtn.classList.toggle('paused', this.isPaused);
        
        if (!this.isPaused) {
          this.lastTime = 0;
        }
      }

      adjustScale(delta) {
        const newScale = Math.max(0.25, Math.min(2, this.scale + delta));
        this.scale = newScale;
        this.scaleSlider.value = newScale;
        this.scaleValue.textContent = `${newScale.toFixed(2)}√ó`;
        this.updateScale(newScale);
      }

      animate(currentTime) {
        const deltaTime = this.lastTime === 0 ? 0 : currentTime - this.lastTime;
        this.lastTime = currentTime;
        
        if (!this.isPaused && deltaTime > 0) {
          const stageWidth = this.stage.clientWidth;
          
          // Update Neil
          this.neil.update(currentTime, deltaTime, stageWidth);
          
          // Update Leela independently
          this.leela.update(currentTime, deltaTime, stageWidth);
        }
        
        // Always render
        this.neil.render();
        this.leela.render();
        
        this.animationId = requestAnimationFrame((t) => this.animate(t));
      }

      destroy() {
        if (this.animationId) {
          cancelAnimationFrame(this.animationId);
        }
      }
    }

    // ============================================
    // SPRITE PRELOADER (silent, no UI)
    // ============================================
    function preloadAllSprites() {
      const sources = [];
      for (const character of Object.values(SPRITES)) {
        for (const sprite of Object.values(character)) {
          if (sprite.src && !sources.includes(sprite.src)) {
            sources.push(sprite.src);
          }
        }
      }

      const loadPromises = sources.map(src => {
        return new Promise((resolve) => {
          const img = new Image();
          img.onload = resolve;
          img.onerror = resolve; // Continue even if one fails
          img.src = src;
        });
      });

      return Promise.all(loadPromises);
    }

    // ============================================
    // EXTENDED WALKING SCENE WITH ENTRANCE
    // ============================================
    class WalkingSceneWithEntrance extends WalkingScene {
      constructor() {
        super();
        this.entranceComplete = false;
        this.isPaused = true; // Start paused during entrance
      }

      setInitialPositions() {
        // Position characters off-screen for entrance
        const stageWidth = this.stage.clientWidth || window.innerWidth;
        
        // Neil starts off-screen left
        this.neil.x = -this.neil.getWidth() - 50;
        this.neil.direction = 1;
        
        // Leela starts off-screen right
        this.leela.x = stageWidth + 50;
        this.leela.direction = -1;
      }

      startEntrance() {
        // Unpause to allow entrance animation
        this.isPaused = false;
        this.entranceComplete = false;
        
        // Target positions
        const stageWidth = this.stage.clientWidth || window.innerWidth;
        this.neilTargetX = CONFIG.edgePadding;
        this.leelaTargetX = stageWidth - this.leela.getWidth() - CONFIG.edgePadding;
        
        // Mark as entering
        this.neil.element.classList.add('entering');
        this.leela.element.classList.add('entering');
      }

      animate(currentTime) {
        const deltaTime = this.lastTime === 0 ? 0 : currentTime - this.lastTime;
        this.lastTime = currentTime;
        
        if (!this.isPaused && deltaTime > 0) {
          const stageWidth = this.stage.clientWidth;
          
          if (!this.entranceComplete) {
            // Entrance animation - just walk to target positions
            this.animateEntrance(currentTime, deltaTime, stageWidth);
          } else {
            // Normal animation
            this.neil.update(currentTime, deltaTime, stageWidth);
            this.leela.update(currentTime, deltaTime, stageWidth);
          }
        }
        
        // Always render
        this.neil.render();
        this.leela.render();
        
        this.animationId = requestAnimationFrame((t) => this.animate(t));
      }

      animateEntrance(currentTime, deltaTime, stageWidth) {
        // Move Neil toward target
        const neilSpeed = (CONFIG.neilSpeed * this.neil.displayScale / this.neil.referenceDisplayScale);
        const neilMove = (neilSpeed * deltaTime) / 1000;
        
        if (this.neil.x < this.neilTargetX) {
          this.neil.x += neilMove;
          if (this.neil.x >= this.neilTargetX) {
            this.neil.x = this.neilTargetX;
          }
        }
        
        // Move Leela toward target
        const leelaSpeed = (LEELA_CONFIG.speed * this.leela.displayScale / this.leela.referenceDisplayScale);
        const leelaMove = (leelaSpeed * deltaTime) / 1000;
        
        if (this.leela.x > this.leelaTargetX) {
          this.leela.x -= leelaMove;
          if (this.leela.x <= this.leelaTargetX) {
            this.leela.x = this.leelaTargetX;
          }
        }
        
        // Update animation frames during entrance
        this.neil.updateAnimation(currentTime);
        this.leela.updateAnimation(currentTime);
        
        // Check if entrance is complete
        if (this.neil.x >= this.neilTargetX && this.leela.x <= this.leelaTargetX) {
          this.entranceComplete = true;
          this.neil.element.classList.remove('entering');
          this.leela.element.classList.remove('entering');
          
          // Reset state machine timing
          this.neil.scheduleNextStateChange(currentTime);
          this.leela.scheduleNextStateChange(currentTime);
        }
      }
    }

    // ============================================
    // ADAPTIVE PERFORMANCE MONITORING
    // ============================================
    let performanceMultiplier = 1.0; // Reduces cloud count when frames drop
    let frameDropCount = 0;
    let frameSampleCount = 0;
    let lastFrameTime = 0;
    const TARGET_FRAME_TIME = 1000 / 30; // Target 30fps minimum
    const FRAME_DROP_THRESHOLD = 0.15; // If more than 15% frames drop, reduce clouds
    const SAMPLE_SIZE = 60; // Check every 60 frames
    const MIN_PERFORMANCE_MULTIPLIER = 0.2; // Don't go below 20% of clouds
    
    function monitorPerformance(currentTime) {
      if (lastFrameTime > 0) {
        const frameTime = currentTime - lastFrameTime;
        frameSampleCount++;
        
        if (frameTime > TARGET_FRAME_TIME) {
          frameDropCount++;
        }
        
        // Check performance every SAMPLE_SIZE frames
        if (frameSampleCount >= SAMPLE_SIZE) {
          const dropRate = frameDropCount / frameSampleCount;
          
          if (dropRate > FRAME_DROP_THRESHOLD && performanceMultiplier > MIN_PERFORMANCE_MULTIPLIER) {
            // Reduce clouds by 20%
            performanceMultiplier = Math.max(MIN_PERFORMANCE_MULTIPLIER, performanceMultiplier * 0.8);
            console.log(`Frame drops detected (${(dropRate * 100).toFixed(1)}%), reducing clouds to ${(performanceMultiplier * 100).toFixed(0)}%`);
            recreateCloudsWithTransition();
          }
          
          // Reset counters
          frameDropCount = 0;
          frameSampleCount = 0;
        }
      }
      lastFrameTime = currentTime;
      requestAnimationFrame(monitorPerformance);
    }
    
    // Start performance monitoring
    requestAnimationFrame(monitorPerformance);

    // ============================================
    // CLOUD GENERATION (matches talking-avatars)
    // ============================================
    let cloudTimelines = []; // Store timelines to kill on recreate
    let lastCloudWidth = 0;
    let isTransitioning = false;
    
    function createClouds(fadeIn = false) {
      const cloudbox = document.getElementById('cloudbox');
      const cloudbox2 = document.getElementById('cloudbox2');
      
      if (!cloudbox || !cloudbox2) return;

      // Kill existing timelines
      cloudTimelines.forEach(tl => tl.kill());
      cloudTimelines = [];
      cloudbox.innerHTML = '';
      cloudbox2.innerHTML = '';

      // Get the sky element's height for positioning
      const sky = document.querySelector('.sky');
      const skyHeight = sky ? sky.clientHeight : window.innerHeight;
      // Clouds should stay in upper portion of sky (300px margin from bottom)
      const cloudAreaHeight = Math.max(50, skyHeight - 300);

      // Calculate speed multiplier based on viewport width
      // Base: 400-900 seconds at 1920px width
      const vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
      const baseWidth = 1920;
      const speedMultiplier = vw / baseWidth;

      function createCloud(container, color) {
        color = color || 'white';
        container.style.setProperty('--cloud-color', color);
        
        // CREATE THE CLOUD SPAN
        const cloud = document.createElement('span');
        cloud.style.width = Math.abs(Math.random() * (180 - 60) + 60) + 'px';
        
        // Start with opacity 0 if fading in
        if (fadeIn) {
          cloud.style.opacity = '0';
        }
        
        // ANIMATION VARIABLES - duration scales with viewport width for consistent perceived speed
        const baseCloudTime = Math.abs(Math.random() * (900 - 400) + 400);
        const cloudTime = baseCloudTime * speedMultiplier;
        const cloudTop = Math.abs(Math.random() * cloudAreaHeight);
        
        // GSAP TIMELINES - horizontal movement only
        const tlAcross = gsap.timeline({ repeat: -1 });
        tlAcross
          .set(cloud, { left: 0, top: cloudTop })
          .seek(cloudTime * Math.random())
          .to(cloud, { duration: cloudTime, left: '100%', ease: 'none' });
        
        // Store timeline for cleanup
        cloudTimelines.push(tlAcross);
        
        // ADD IT TO THE CONTAINER
        container.appendChild(cloud);
        
        return cloud;
      }

      // Calculate cloud count based on viewport width AND sky height
      // Base: 120 clouds per layer at 1920px width x 600px height
      // Also applies performanceMultiplier for adaptive performance
      lastCloudWidth = vw;
      const baseHeight = 600;
      const baseClouds = 120;
      const widthFactor = vw / baseWidth;
      const heightFactor = skyHeight / baseHeight;
      const baseCloudCount = Math.round(baseClouds * widthFactor * heightFactor);
      const cloudCount = Math.max(10, Math.round(baseCloudCount * performanceMultiplier));

      const newClouds = [];
      
      // Create white clouds in front layer
      for (let i = 0; i < cloudCount; i++) {
        newClouds.push(createCloud(cloudbox, 'white'));
      }

      // Create darker grey clouds in back layer (more visible contrast)
      for (let i = 0; i < cloudCount; i++) {
        newClouds.push(createCloud(cloudbox2, '#a0a0a0'));
      }
      
      // Fade in new clouds if requested
      if (fadeIn) {
        gsap.to(newClouds, { 
          opacity: 1, 
          duration: 1, 
          stagger: 0.01,
          onComplete: () => {
            isTransitioning = false;
          }
        });
      }
    }
    
    function recreateCloudsWithTransition() {
      if (isTransitioning) return;
      isTransitioning = true;
      
      const cloudbox = document.getElementById('cloudbox');
      const cloudbox2 = document.getElementById('cloudbox2');
      
      // Get all existing clouds
      const existingClouds = [
        ...cloudbox.querySelectorAll('span'),
        ...cloudbox2.querySelectorAll('span')
      ];
      
      // Fade out existing clouds
      gsap.to(existingClouds, {
        opacity: 0,
        duration: 0.8,
        onComplete: () => {
          // Create new clouds with fade in
          createClouds(true);
        }
      });
    }

    // Debounced resize handler for clouds
    let cloudResizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(cloudResizeTimeout);
      cloudResizeTimeout = setTimeout(() => {
        const vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
        // Only recreate if width changed significantly (more than 200px)
        if (Math.abs(vw - lastCloudWidth) > 200) {
          recreateCloudsWithTransition();
        }
      }, 300);
    });

    // ============================================
    // INITIALIZE
    // ============================================
    async function init() {
      // Check for screensaver mode
      const urlParams = new URLSearchParams(window.location.search);
      const isScreensaver = urlParams.has('screensaver');
      
      if (isScreensaver) {
        document.body.classList.add('screensaver');
      }

      // Check for custom ground height
      // Default: 80px ground height
      // Characters are positioned 20px into the ground (feet embedded in grass)
      const DEFAULT_GROUND_HEIGHT = 80;
      const CHARACTER_GROUND_OFFSET = 20; // How far into the ground the characters' feet are
      const ABOVE_GROUND_CLEARANCE = 60; // Space above ground for character rendering
      
      const groundHeightParam = urlParams.get('groundHeight');
      if (groundHeightParam) {
        const groundHeight = parseInt(groundHeightParam, 10);
        if (!isNaN(groundHeight) && groundHeight > 0) {
          const root = document.documentElement;
          root.style.setProperty('--ground-height', `${groundHeight}px`);
          root.style.setProperty('--ground-area-height', `${groundHeight + ABOVE_GROUND_CLEARANCE}px`);
          root.style.setProperty('--walking-stage-bottom', `${groundHeight - CHARACTER_GROUND_OFFSET}px`);
        }
      }

      // Create cloud layers
      createClouds();

      // Preload all sprites silently, then start entrance animation
      await preloadAllSprites();
      
      // Create scene and start entrance animation
      const scene = new WalkingSceneWithEntrance();
      scene.startEntrance();
    }

    // Start when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init);
    } else {
      init();
    }
  </script>

  <!-- SVG filter for cloud goo effect -->
  <svg class="hidden-svg">
    <defs>
      <filter id="fancy-goo">
        <feGaussianBlur in="SourceGraphic" stdDeviation="5" result="blur" />
        <feColorMatrix in="blur" mode="matrix" values="1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 19 -9" result="goo" />
        <feComposite in="SourceGraphic" in2="goo" operator="atop" />
      </filter>
    </defs>
  </svg>
</body>
</html>
