<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Neil & Leela Walking Scene</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      background: #1a1a2e;
      height: 100dvh; /* Dynamic viewport height for mobile */
      height: 100vh; /* Fallback for older browsers */
      color: #fff;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    @supports (height: 100dvh) {
      body {
        height: 100dvh;
      }
    }

    /* Header */
    .header {
      padding: 1rem 2rem;
      text-align: center;
      background: rgba(0, 0, 0, 0.3);
      backdrop-filter: blur(10px);
      z-index: 100;
    }

    h1 {
      font-size: 1.75rem;
      background: linear-gradient(90deg, #e94560, #f39c12);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 0.25rem;
    }

    .subtitle {
      color: #a0a0a0;
      font-size: 0.85rem;
    }

    /* Controls */
    .controls {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 2rem;
      padding: 1rem 2rem;
      background: rgba(0, 0, 0, 0.2);
      flex-wrap: wrap;
    }

    .control-group {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .control-group label {
      font-weight: 500;
      color: #e0e0e0;
      font-size: 0.9rem;
    }

    button {
      background: linear-gradient(135deg, #e94560, #c23d51);
      color: white;
      border: none;
      padding: 0.6rem 1.25rem;
      border-radius: 8px;
      font-size: 0.9rem;
      cursor: pointer;
      transition: all 0.2s ease;
      font-weight: 600;
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(233, 69, 96, 0.4);
    }

    button:active {
      transform: translateY(0);
    }

    button.paused {
      background: linear-gradient(135deg, #27ae60, #1e8449);
    }

    button.paused:hover {
      box-shadow: 0 4px 15px rgba(39, 174, 96, 0.4);
    }

    input[type="range"] {
      width: 120px;
      height: 6px;
      border-radius: 3px;
      background: rgba(255, 255, 255, 0.2);
      outline: none;
      -webkit-appearance: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #e94560;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    input[type="range"]::-webkit-slider-thumb:hover {
      transform: scale(1.2);
    }

    .value-display {
      min-width: 50px;
      text-align: center;
      background: rgba(255, 255, 255, 0.1);
      padding: 0.2rem 0.4rem;
      border-radius: 4px;
      font-family: monospace;
      font-size: 0.85rem;
    }

    /* Scene Container - uses flexbox to push ground to bottom */
    .scene-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      min-height: 0; /* Allow shrinking */
    }

    /* Sky - flexible area that expands/contracts */
    .sky {
      flex: 1;
      min-height: 50px;
      background: linear-gradient(
        to bottom,
        #1a1a2e 0%,
        #16213e 40%,
        #0f3460 100%
      );
    }

    /* Ground area - fixed height at bottom */
    .ground-area {
      position: relative;
      height: 140px; /* Ground height + walking space */
      flex-shrink: 0;
      background: #0f3460; /* Match sky gradient bottom color */
    }

    /* Ground */
    .ground {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 80px;
      background: linear-gradient(
        to bottom,
        #2d5016 0%,
        #1a3a0a 30%,
        #0f2505 100%
      );
      border-top: 3px solid #3d6b1e;
    }

    /* Ground texture (grass blades hint) */
    .ground::before {
      content: '';
      position: absolute;
      top: -5px;
      left: 0;
      right: 0;
      height: 10px;
      background: repeating-linear-gradient(
        90deg,
        transparent 0px,
        transparent 8px,
        #3d6b1e 8px,
        #3d6b1e 10px,
        transparent 10px,
        transparent 20px
      );
      opacity: 0.6;
    }

    /* Walking Stage - where characters walk, above the ground */
    .walking-stage {
      position: absolute;
      bottom: 60px;
      left: 0;
      right: 0;
      top: 0;
    }

    /* Character sprites */
    .character {
      position: absolute;
      bottom: 0; /* Align by bottom (feet on ground) */
      will-change: transform, left;
    }

    /* Shadow under characters */
    .character::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 110%;
      height: 12px;
      background: radial-gradient(ellipse at center, rgba(0,0,0,0.4) 0%, rgba(0,0,0,0.2) 40%, transparent 70%);
      border-radius: 50%;
      z-index: -1;
    }

    .sprite-neil {
      background-image: url('./neil-walk-spritesheet.png');
      background-repeat: no-repeat;
    }

    .sprite-leela {
      background-image: url('./leela-walk-spritesheet.png');
      background-repeat: no-repeat;
    }

    /* Leela's shadow is smaller */
    .sprite-leela::after {
      width: 120%;
      height: 8px;
    }

    /* Keyboard hints */
    .keyboard-hints {
      display: flex;
      gap: 1rem;
      justify-content: center;
      padding: 0.5rem;
      background: rgba(0, 0, 0, 0.2);
      font-size: 0.75rem;
      color: #888;
    }

    .keyboard-hint kbd {
      background: rgba(255, 255, 255, 0.15);
      padding: 0.15rem 0.4rem;
      border-radius: 3px;
      margin-right: 0.25rem;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>üêï Neil & Leela Walking Scene</h1>
    <p class="subtitle">Watch them walk back and forth across the screen!</p>
  </div>

  <div class="controls">
    <div class="control-group">
      <button id="playPauseBtn">‚è∏ Pause</button>
    </div>
    <div class="control-group">
      <label for="scaleSlider">Scale:</label>
      <input type="range" id="scaleSlider" min="0.25" max="2" step="0.05" value="0.75">
      <span id="scaleValue" class="value-display">0.75√ó</span>
    </div>
  </div>

  <div class="keyboard-hints">
    <span class="keyboard-hint"><kbd>Space</kbd> Play/Pause</span>
    <span class="keyboard-hint"><kbd>+</kbd><kbd>-</kbd> Adjust Scale</span>
  </div>

  <div class="scene-container">
    <div class="sky"></div>
    <div class="ground-area">
      <div class="walking-stage" id="walkingStage">
        <!-- Characters will be added via JavaScript -->
      </div>
      <div class="ground"></div>
    </div>
  </div>

  <script>
    // ============================================
    // SPRITE SHEET SPECIFICATIONS
    // ============================================
    const SPRITES = {
      neil: {
        cols: 6,
        rows: 6,
        totalFrames: 36,
        frameWidth: 163,
        frameHeight: 268,
        sheetWidth: 978,
        sheetHeight: 1608,
        fps: 10
      },
      leela: {
        cols: 6,
        rows: 6,
        totalFrames: 36,
        frameWidth: 287,
        frameHeight: 269,
        sheetWidth: 1722,
        sheetHeight: 1614,
        fps: 23
      }
    };

    // Configuration
    const CONFIG = {
      neilSpeed: 80,        // pixels per second (calibrated at reference scale)
      leelaSpeed: 55,       // pixels per second (calibrated at reference scale)
      leelaHeightRatio: 0.4, // Leela's height relative to Neil
      edgePadding: 50,      // pixels from edge before turning
      referenceScale: 0.75  // The scale at which speeds are calibrated
    };

    // ============================================
    // CHARACTER CLASS
    // ============================================
    class Character {
      constructor(name, spriteConfig, movementSpeed, stage) {
        this.name = name;
        this.config = spriteConfig;
        this.speed = movementSpeed;
        this.stage = stage;
        
        // Animation state
        this.currentFrame = 0;
        this.lastFrameTime = 0;
        this.frameInterval = 1000 / spriteConfig.fps;
        
        // Position state
        this.x = 0;
        this.direction = 1; // 1 = moving right, -1 = moving left
        
        // Display scale (will be set by updateScale)
        this.displayScale = 1;
        this.referenceDisplayScale = null; // Set on first scale to track reference
        
        // Create DOM element
        this.element = document.createElement('div');
        this.element.className = `character sprite-${name}`;
        this.stage.appendChild(this.element);
      }

      /**
       * Set display scale and update element dimensions
       */
      setScale(scale) {
        // Capture reference scale on first call (at default slider value)
        if (this.referenceDisplayScale === null) {
          this.referenceDisplayScale = scale;
        }
        
        this.displayScale = scale;
        
        const width = this.config.frameWidth * scale;
        const height = this.config.frameHeight * scale;
        const sheetW = this.config.sheetWidth * scale;
        const sheetH = this.config.sheetHeight * scale;
        
        this.element.style.width = `${width}px`;
        this.element.style.height = `${height}px`;
        this.element.style.backgroundSize = `${sheetW}px ${sheetH}px`;
        
        // Re-render to update background position
        this.render();
      }

      /**
       * Get current display width
       */
      getWidth() {
        return this.config.frameWidth * this.displayScale;
      }

      /**
       * Update animation frame and position
       */
      update(currentTime, deltaTime, stageWidth) {
        // Update animation frame based on FPS
        if (currentTime - this.lastFrameTime >= this.frameInterval) {
          this.currentFrame = (this.currentFrame + 1) % this.config.totalFrames;
          this.lastFrameTime = currentTime;
        }
        
        // Update position - scale movement relative to each character's reference scale
        // This keeps the "slide per cycle" visually consistent across different scales
        const scaleRatio = this.displayScale / this.referenceDisplayScale;
        const movement = (this.speed * scaleRatio * deltaTime) / 1000;
        this.x += movement * this.direction;
        
        // Check boundaries and reverse direction
        const charWidth = this.getWidth();
        const minX = CONFIG.edgePadding;
        const maxX = stageWidth - charWidth - CONFIG.edgePadding;
        
        if (this.x >= maxX) {
          this.x = maxX;
          this.direction = -1; // Turn left
        } else if (this.x <= minX) {
          this.x = minX;
          this.direction = 1; // Turn right
        }
      }

      /**
       * Render current state to DOM
       */
      render() {
        // Update background position for current frame
        const col = this.currentFrame % this.config.cols;
        const row = Math.floor(this.currentFrame / this.config.cols);
        const bgX = -(col * this.config.frameWidth * this.displayScale);
        const bgY = -(row * this.config.frameHeight * this.displayScale);
        
        this.element.style.backgroundPosition = `${bgX}px ${bgY}px`;
        
        // Update position
        this.element.style.left = `${this.x}px`;
        
        // Flip sprite based on direction
        // Walking LEFT (direction = -1): normal orientation
        // Walking RIGHT (direction = 1): flip horizontally
        if (this.direction === 1) {
          this.element.style.transform = 'scaleX(-1)';
        } else {
          this.element.style.transform = 'scaleX(1)';
        }
        
        // Z-index: Leela always in front of Neil when overlapping
        // Leela gets base z-index of 20, Neil gets 10
        // This ensures consistent layering regardless of position
        const baseZ = this.name === 'leela' ? 20 : 10;
        this.element.style.zIndex = baseZ;
      }
    }

    // ============================================
    // SCENE MANAGER
    // ============================================
    class WalkingScene {
      constructor() {
        this.stage = document.getElementById('walkingStage');
        this.characters = [];
        this.isPaused = false;
        this.scale = 0.75;
        this.lastTime = 0;
        this.animationId = null;
        
        // DOM elements
        this.playPauseBtn = document.getElementById('playPauseBtn');
        this.scaleSlider = document.getElementById('scaleSlider');
        this.scaleValue = document.getElementById('scaleValue');
        
        // Initialize
        this.createCharacters();
        this.bindEvents();
        this.updateScale(this.scale);
        this.setInitialPositions();
        
        // Start animation
        this.animationId = requestAnimationFrame((t) => this.animate(t));
      }

      /**
       * Create Neil and Leela characters
       */
      createCharacters() {
        // Create Neil
        this.neil = new Character('neil', SPRITES.neil, CONFIG.neilSpeed, this.stage);
        this.characters.push(this.neil);
        
        // Create Leela
        this.leela = new Character('leela', SPRITES.leela, CONFIG.leelaSpeed, this.stage);
        this.characters.push(this.leela);
      }

      /**
       * Set initial positions (spread them out)
       */
      setInitialPositions() {
        const stageWidth = this.stage.clientWidth || window.innerWidth;
        
        // Neil starts from the left
        this.neil.x = CONFIG.edgePadding;
        this.neil.direction = 1; // Walking right
        
        // Leela starts from the right (but walks left initially)
        this.leela.x = stageWidth - this.leela.getWidth() - CONFIG.edgePadding;
        this.leela.direction = -1; // Walking left
      }

      /**
       * Update scale for all characters
       */
      updateScale(newScale) {
        this.scale = newScale;
        
        // Neil uses base scale
        this.neil.setScale(newScale);
        
        // Leela's height should be LEELA_HEIGHT_RATIO of Neil's height
        // Neil's displayed height = SPRITES.neil.frameHeight * scale
        // Leela's target height = Neil's height * LEELA_HEIGHT_RATIO
        // Leela's scale = targetHeight / SPRITES.leela.frameHeight
        const neilDisplayHeight = SPRITES.neil.frameHeight * newScale;
        const leelaTargetHeight = neilDisplayHeight * CONFIG.leelaHeightRatio;
        const leelaScale = leelaTargetHeight / SPRITES.leela.frameHeight;
        this.leela.setScale(leelaScale);
      }

      /**
       * Bind event listeners
       */
      bindEvents() {
        // Play/Pause button
        this.playPauseBtn.addEventListener('click', () => this.togglePlayPause());
        
        // Scale slider
        this.scaleSlider.addEventListener('input', (e) => {
          const newScale = parseFloat(e.target.value);
          this.scaleValue.textContent = `${newScale}√ó`;
          this.updateScale(newScale);
        });
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
          switch (e.code) {
            case 'Space':
              e.preventDefault();
              this.togglePlayPause();
              break;
            case 'Equal':
            case 'NumpadAdd':
              e.preventDefault();
              this.adjustScale(0.05);
              break;
            case 'Minus':
            case 'NumpadSubtract':
              e.preventDefault();
              this.adjustScale(-0.05);
              break;
          }
        });
        
        // Handle window resize
        window.addEventListener('resize', () => {
          // Ensure characters stay within bounds
          const stageWidth = this.stage.clientWidth;
          this.characters.forEach(char => {
            const maxX = stageWidth - char.getWidth() - CONFIG.edgePadding;
            if (char.x > maxX) {
              char.x = maxX;
            }
          });
        });
      }

      /**
       * Toggle play/pause state
       */
      togglePlayPause() {
        this.isPaused = !this.isPaused;
        this.playPauseBtn.textContent = this.isPaused ? '‚ñ∂ Play' : '‚è∏ Pause';
        this.playPauseBtn.classList.toggle('paused', this.isPaused);
        
        if (!this.isPaused) {
          // Reset lastTime to prevent jump after unpause
          this.lastTime = 0;
        }
      }

      /**
       * Adjust scale by delta
       */
      adjustScale(delta) {
        const newScale = Math.max(0.25, Math.min(2, this.scale + delta));
        this.scale = newScale;
        this.scaleSlider.value = newScale;
        this.scaleValue.textContent = `${newScale.toFixed(2)}√ó`;
        this.updateScale(newScale);
      }

      /**
       * Animation loop
       */
      animate(currentTime) {
        // Calculate delta time
        const deltaTime = this.lastTime === 0 ? 0 : currentTime - this.lastTime;
        this.lastTime = currentTime;
        
        if (!this.isPaused && deltaTime > 0) {
          const stageWidth = this.stage.clientWidth;
          
          // Update all characters
          this.characters.forEach(char => {
            char.update(currentTime, deltaTime, stageWidth);
          });
        }
        
        // Always render (even when paused, to reflect scale changes)
        this.characters.forEach(char => char.render());
        
        // Continue animation loop
        this.animationId = requestAnimationFrame((t) => this.animate(t));
      }

      /**
       * Cleanup
       */
      destroy() {
        if (this.animationId) {
          cancelAnimationFrame(this.animationId);
        }
      }
    }

    // ============================================
    // INITIALIZE SCENE
    // ============================================
    const scene = new WalkingScene();
  </script>
</body>
</html>
