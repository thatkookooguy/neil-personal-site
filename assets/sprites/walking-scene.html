<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Neil & Leela Walking Scene</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      background: #1a1a2e;
      height: 100dvh; /* Dynamic viewport height for mobile */
      height: 100vh; /* Fallback for older browsers */
      color: #fff;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    @supports (height: 100dvh) {
      body {
        height: 100dvh;
      }
    }

    /* Header */
    .header {
      padding: 1rem 2rem;
      text-align: center;
      background: rgba(0, 0, 0, 0.3);
      backdrop-filter: blur(10px);
      z-index: 100;
    }

    h1 {
      font-size: 1.75rem;
      background: linear-gradient(90deg, #e94560, #f39c12);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 0.25rem;
    }

    .subtitle {
      color: #a0a0a0;
      font-size: 0.85rem;
    }

    /* Controls */
    .controls {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 2rem;
      padding: 1rem 2rem;
      background: rgba(0, 0, 0, 0.2);
      flex-wrap: wrap;
    }

    .control-group {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .control-group label {
      font-weight: 500;
      color: #e0e0e0;
      font-size: 0.9rem;
    }

    button {
      background: linear-gradient(135deg, #e94560, #c23d51);
      color: white;
      border: none;
      padding: 0.6rem 1.25rem;
      border-radius: 8px;
      font-size: 0.9rem;
      cursor: pointer;
      transition: all 0.2s ease;
      font-weight: 600;
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(233, 69, 96, 0.4);
    }

    button:active {
      transform: translateY(0);
    }

    button.paused {
      background: linear-gradient(135deg, #27ae60, #1e8449);
    }

    button.paused:hover {
      box-shadow: 0 4px 15px rgba(39, 174, 96, 0.4);
    }

    input[type="range"] {
      width: 120px;
      height: 6px;
      border-radius: 3px;
      background: rgba(255, 255, 255, 0.2);
      outline: none;
      -webkit-appearance: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #e94560;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    input[type="range"]::-webkit-slider-thumb:hover {
      transform: scale(1.2);
    }

    .value-display {
      min-width: 50px;
      text-align: center;
      background: rgba(255, 255, 255, 0.1);
      padding: 0.2rem 0.4rem;
      border-radius: 4px;
      font-family: monospace;
      font-size: 0.85rem;
    }

    /* Scene Container - uses flexbox to push ground to bottom */
    .scene-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      min-height: 0; /* Allow shrinking */
    }

    /* Sky - flexible area that expands/contracts */
    .sky {
      flex: 1;
      min-height: 50px;
      background: linear-gradient(
        to bottom,
        #1a1a2e 0%,
        #16213e 40%,
        #0f3460 100%
      );
    }

    /* Ground area - fixed height at bottom */
    .ground-area {
      position: relative;
      height: 140px; /* Ground height + walking space */
      flex-shrink: 0;
      background: #0f3460; /* Match sky gradient bottom color */
    }

    /* Ground */
    .ground {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 80px;
      background: linear-gradient(
        to bottom,
        #2d5016 0%,
        #1a3a0a 30%,
        #0f2505 100%
      );
      border-top: 3px solid #3d6b1e;
    }

    /* Ground texture (grass blades hint) */
    .ground::before {
      content: '';
      position: absolute;
      top: -5px;
      left: 0;
      right: 0;
      height: 10px;
      background: repeating-linear-gradient(
        90deg,
        transparent 0px,
        transparent 8px,
        #3d6b1e 8px,
        #3d6b1e 10px,
        transparent 10px,
        transparent 20px
      );
      opacity: 0.6;
    }

    /* Walking Stage - where characters walk, above the ground */
    .walking-stage {
      position: absolute;
      bottom: 60px;
      left: 0;
      right: 0;
      top: 0;
    }

    /* Character sprites */
    .character {
      position: absolute;
      bottom: 0; /* Align by bottom (feet on ground) */
      will-change: transform, left;
    }

    /* Shadow under characters */
    .character::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 110%;
      height: 12px;
      background: radial-gradient(ellipse at center, rgba(0,0,0,0.4) 0%, rgba(0,0,0,0.2) 40%, transparent 70%);
      border-radius: 50%;
      z-index: -1;
    }

    .sprite-neil {
      background-repeat: no-repeat;
      transition: opacity 0.15s ease-out;
    }
    
    .sprite-neil.transitioning {
      opacity: 0.7;
    }

    .sprite-leela {
      background-image: url('./leela-walk-spritesheet.png');
      background-repeat: no-repeat;
    }

    /* Leela's shadow is smaller */
    .sprite-leela::after {
      width: 120%;
      height: 8px;
    }

    /* Keyboard hints */
    .keyboard-hints {
      display: flex;
      gap: 1rem;
      justify-content: center;
      padding: 0.5rem;
      background: rgba(0, 0, 0, 0.2);
      font-size: 0.75rem;
      color: #888;
    }

    .keyboard-hint kbd {
      background: rgba(255, 255, 255, 0.15);
      padding: 0.15rem 0.4rem;
      border-radius: 3px;
      margin-right: 0.25rem;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    /* State indicator for debugging - uses separate positioning to avoid flip */
    .state-indicator {
      position: absolute;
      top: -20px;
      left: 50%;
      font-size: 10px;
      background: rgba(0,0,0,0.5);
      padding: 2px 6px;
      border-radius: 3px;
      white-space: nowrap;
      opacity: 0;
      transition: opacity 0.3s;
      pointer-events: none;
    }

    .character:hover .state-indicator {
      opacity: 1;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>üêï Neil & Leela Walking Scene</h1>
    <p class="subtitle">Watch them walk back and forth across the screen!</p>
  </div>

  <div class="controls">
    <div class="control-group">
      <button id="playPauseBtn">‚è∏ Pause</button>
    </div>
    <div class="control-group">
      <label for="scaleSlider">Scale:</label>
      <input type="range" id="scaleSlider" min="0.25" max="2" step="0.05" value="0.75">
      <span id="scaleValue" class="value-display">0.75√ó</span>
    </div>
  </div>

  <div class="keyboard-hints">
    <span class="keyboard-hint"><kbd>Space</kbd> Play/Pause</span>
    <span class="keyboard-hint"><kbd>+</kbd><kbd>-</kbd> Adjust Scale</span>
  </div>

  <div class="scene-container">
    <div class="sky"></div>
    <div class="ground-area">
      <div class="walking-stage" id="walkingStage">
        <!-- Characters will be added via JavaScript -->
      </div>
      <div class="ground"></div>
    </div>
  </div>

  <script>
    // ============================================
    // SPRITE SHEET SPECIFICATIONS
    // ============================================
    const SPRITES = {
      neil: {
        walk: {
          src: './neil-walk-spritesheet.png',
          cols: 6,
          rows: 6,
          totalFrames: 36,
          frameWidth: 163,
          frameHeight: 268,
          sheetWidth: 978,
          sheetHeight: 1608,
          fps: 10
        },
        idle: {
          src: './neil-idle-spritesheet.png',
          cols: 6,
          rows: 6,
          totalFrames: 36,
          frameWidth: 226,
          frameHeight: 450,
          sheetWidth: 1356,
          sheetHeight: 2700,
          fps: 12
        },
        thinking: {
          src: './neil-thinking-spritesheet.png',
          cols: 6,
          rows: 6,
          totalFrames: 36,
          frameWidth: 213,
          frameHeight: 260,
          sheetWidth: 1278,
          sheetHeight: 1560,
          fps: 10
        }
      },
      leela: {
        walk: {
          src: './leela-walk-spritesheet.png',
          cols: 6,
          rows: 6,
          totalFrames: 36,
          frameWidth: 287,
          frameHeight: 269,
          sheetWidth: 1722,
          sheetHeight: 1614,
          fps: 23
        }
      }
    };

    // Configuration
    const CONFIG = {
      neilSpeed: 80,
      leelaSpeed: 55,
      leelaHeightRatio: 0.4,
      edgePadding: 50,
      referenceScale: 0.75,
      // State machine timing (in milliseconds)
      minWalkTime: 3000,      // Walk at least 3 seconds before potentially stopping
      maxWalkTime: 8000,      // Walk at most 8 seconds before stopping
      minIdleCycles: 3,       // Idle at least 3 full animation cycles
      maxIdleTime: 5000,      // Idle at most 5 seconds
      thinkingChance: 0.35,   // 35% chance to think during idle
      minThinkCycles: 1,      // Think at least 1 full animation cycle
      maxThinkTime: 6000,     // Think at most 6 seconds
      postThinkIdleTime: 800, // Brief idle after thinking before walking
      // Animation speed multipliers (lower = slower)
      idleAnimSpeed: 0.7,     // Idle animation 70% speed
      thinkingAnimSpeed: 0.7, // Thinking animation 70% speed
      // Easing transitions
      slowDownDuration: 800,  // ms to slow down before stopping
      speedUpDuration: 700,   // ms to speed up when starting to walk
      // Position offsets to align different sprites (in pixels at scale 1)
      // Separate values for each direction since sprites may be asymmetric
      spriteOffsets: {
        // When walking RIGHT (direction = 1, sprite flipped)
        right: {
          walk: 0,
          idle: 20,
          thinking: -15
        },
        // When walking LEFT (direction = -1, sprite normal)
        left: {
          walk: 0,
          idle: 20,      // Move right compared to walk
          thinking: -15  // Move left compared to walk
        }
      },
      transitionDuration: 150  // ms for state transition fade
    };

    // ============================================
    // NEIL CHARACTER CLASS (with state machine)
    // ============================================
    class NeilCharacter {
      constructor(stage) {
        this.name = 'neil';
        this.stage = stage;
        
        // State machine
        // States: walking, slowing, idle, thinking, post-think-idle, speeding
        this.state = 'walking';
        this.stateStartTime = 0;
        this.nextStateChangeTime = 0;
        
        // Speed multiplier for easing (1 = full speed, 0 = stopped)
        this.speedMultiplier = 1;
        
        // Current sprite config (starts with walk)
        this.currentSprite = 'walk';
        this.config = SPRITES.neil.walk;
        
        // Animation state
        this.currentFrame = 0;
        this.lastFrameTime = 0;
        this.frameInterval = 1000 / this.config.fps;
        
        // Position state
        this.x = 0;
        this.direction = 1;
        this.speed = CONFIG.neilSpeed;
        
        // Display scale
        this.displayScale = 1;
        this.referenceDisplayScale = null;
        
        // Create DOM element
        this.element = document.createElement('div');
        this.element.className = 'character sprite-neil';
        this.element.style.backgroundImage = `url('${this.config.src}')`;
        
        // State indicator (hover to see)
        this.stateIndicator = document.createElement('div');
        this.stateIndicator.className = 'state-indicator';
        this.element.appendChild(this.stateIndicator);
        
        this.stage.appendChild(this.element);
        
        // Schedule first state change
        this.scheduleNextStateChange(performance.now());
      }

      /**
       * Get random time between min and max
       */
      randomBetween(min, max) {
        return min + Math.random() * (max - min);
      }

      /**
       * Calculate how long one full animation cycle takes for a sprite
       */
      getAnimCycleDuration(spriteName, speedMultiplier = 1) {
        const sprite = SPRITES.neil[spriteName];
        const baseFrameTime = 1000 / sprite.fps;
        const effectiveFrameTime = baseFrameTime / speedMultiplier;
        return effectiveFrameTime * sprite.totalFrames;
      }

      /**
       * Schedule when the next state change should happen
       */
      scheduleNextStateChange(currentTime) {
        this.stateStartTime = currentTime;
        
        switch (this.state) {
          case 'walking':
            this.nextStateChangeTime = currentTime + this.randomBetween(CONFIG.minWalkTime, CONFIG.maxWalkTime);
            break;
          case 'slowing':
            this.nextStateChangeTime = currentTime + CONFIG.slowDownDuration;
            break;
          case 'idle': {
            // Minimum time = at least N full animation cycles
            const cycleDuration = this.getAnimCycleDuration('idle', CONFIG.idleAnimSpeed);
            const minTime = cycleDuration * CONFIG.minIdleCycles;
            this.nextStateChangeTime = currentTime + this.randomBetween(minTime, CONFIG.maxIdleTime);
            break;
          }
          case 'thinking': {
            // Minimum time = at least N full animation cycles
            const cycleDuration = this.getAnimCycleDuration('thinking', CONFIG.thinkingAnimSpeed);
            const minTime = cycleDuration * CONFIG.minThinkCycles;
            this.nextStateChangeTime = currentTime + this.randomBetween(minTime, CONFIG.maxThinkTime);
            break;
          }
          case 'post-think-idle':
            this.nextStateChangeTime = currentTime + CONFIG.postThinkIdleTime;
            break;
          case 'speeding':
            this.nextStateChangeTime = currentTime + CONFIG.speedUpDuration;
            break;
        }
      }

      /**
       * Switch to a different sprite sheet with smooth transition
       */
      switchSprite(spriteName) {
        if (this.currentSprite === spriteName) return;
        
        // Brief opacity dip for smoother transition
        this.element.classList.add('transitioning');
        
        // Switch sprite immediately
        this.currentSprite = spriteName;
        this.config = SPRITES.neil[spriteName];
        this.currentFrame = 0;
        this.frameInterval = 1000 / this.config.fps;
        
        // Update background image
        this.element.style.backgroundImage = `url('${this.config.src}')`;
        
        // Reapply scale with new sprite dimensions
        this.applyScale();
        
        // Remove transitioning class after transition completes
        setTimeout(() => {
          this.element.classList.remove('transitioning');
        }, CONFIG.transitionDuration);
      }

      /**
       * Transition to a new state
       */
      transitionTo(newState, currentTime) {
        this.state = newState;
        this.scheduleNextStateChange(currentTime);
        
        // Switch sprite based on state
        switch (newState) {
          case 'walking':
          case 'slowing':
          case 'speeding':
            this.switchSprite('walk');
            break;
          case 'idle':
          case 'post-think-idle':
            this.switchSprite('idle');
            break;
          case 'thinking':
            this.switchSprite('thinking');
            break;
        }
      }

      /**
       * Check if it's time to change state and do so
       */
      updateStateMachine(currentTime) {
        if (currentTime < this.nextStateChangeTime) return;
        
        switch (this.state) {
          case 'walking':
            // Start slowing down before idle
            this.transitionTo('slowing', currentTime);
            break;
          
          case 'slowing':
            // Finished slowing, now idle
            this.speedMultiplier = 0;
            this.transitionTo('idle', currentTime);
            break;
            
          case 'idle':
            // Either think or start speeding up to walk
            if (Math.random() < CONFIG.thinkingChance) {
              this.transitionTo('thinking', currentTime);
            } else {
              this.transitionTo('speeding', currentTime);
            }
            break;
            
          case 'thinking':
            // Brief idle before walking again
            this.transitionTo('post-think-idle', currentTime);
            break;
            
          case 'post-think-idle':
            // Start speeding up
            this.transitionTo('speeding', currentTime);
            break;
          
          case 'speeding':
            // Finished speeding up, now walking at full speed
            this.speedMultiplier = 1;
            this.transitionTo('walking', currentTime);
            break;
        }
      }

      /**
       * Set display scale
       */
      setScale(scale) {
        if (this.referenceDisplayScale === null) {
          this.referenceDisplayScale = scale;
        }
        this.displayScale = scale;
        this.applyScale();
      }

      /**
       * Apply current scale to element
       * Normalizes all sprites to have the same height as the walk sprite
       */
      applyScale() {
        const baseScale = this.displayScale;
        
        // Target height is based on walk sprite at current scale
        const targetHeight = SPRITES.neil.walk.frameHeight * baseScale;
        
        // Calculate the scale factor needed for current sprite to match target height
        const spriteScale = targetHeight / this.config.frameHeight;
        
        const width = this.config.frameWidth * spriteScale;
        const height = this.config.frameHeight * spriteScale;
        const sheetW = this.config.sheetWidth * spriteScale;
        const sheetH = this.config.sheetHeight * spriteScale;
        
        // Store the actual sprite scale for rendering
        this.actualSpriteScale = spriteScale;
        
        this.element.style.width = `${width}px`;
        this.element.style.height = `${height}px`;
        this.element.style.backgroundSize = `${sheetW}px ${sheetH}px`;
        
        this.render();
      }

      getWidth() {
        return this.config.frameWidth * this.displayScale;
      }

      /**
       * Update animation and position
       */
      update(currentTime, deltaTime, stageWidth) {
        // Update state machine
        this.updateStateMachine(currentTime);
        
        // Update speed multiplier during easing states
        if (this.state === 'slowing') {
          // Ease out: 1 ‚Üí 0 over slowDownDuration
          const elapsed = currentTime - this.stateStartTime;
          const progress = Math.min(1, elapsed / CONFIG.slowDownDuration);
          // Use cubic ease-out curve (smooth deceleration)
          this.speedMultiplier = 1 - this.easeOutCubic(progress);
        } else if (this.state === 'speeding') {
          // Ease in: 0 ‚Üí 1 over speedUpDuration
          const elapsed = currentTime - this.stateStartTime;
          const progress = Math.min(1, elapsed / CONFIG.speedUpDuration);
          // Use cubic ease-in curve (starts very slow, then accelerates)
          this.speedMultiplier = this.easeInCubic(progress);
        }
        
        // Update animation frame (scale frame rate based on state)
        let effectiveFrameInterval = this.frameInterval;
        
        if (this.state === 'slowing' || this.state === 'speeding') {
          // Slow down animation proportionally to movement speed
          // Use a minimum of 0.05 to prevent complete freeze, max interval of 500ms
          const animSpeed = Math.max(0.05, this.speedMultiplier);
          effectiveFrameInterval = Math.min(500, this.frameInterval / animSpeed);
        } else if (this.state === 'idle' || this.state === 'post-think-idle') {
          // Idle animation runs slower
          effectiveFrameInterval = this.frameInterval / CONFIG.idleAnimSpeed;
        } else if (this.state === 'thinking') {
          // Thinking animation runs even slower
          effectiveFrameInterval = this.frameInterval / CONFIG.thinkingAnimSpeed;
        }
        
        if (currentTime - this.lastFrameTime >= effectiveFrameInterval) {
          this.currentFrame = (this.currentFrame + 1) % this.config.totalFrames;
          this.lastFrameTime = currentTime;
        }
        
        // Move when walking, slowing, or speeding (using speedMultiplier)
        if (this.state === 'walking' || this.state === 'slowing' || this.state === 'speeding') {
          const scaleRatio = this.displayScale / this.referenceDisplayScale;
          const movement = (this.speed * this.speedMultiplier * scaleRatio * deltaTime) / 1000;
          this.x += movement * this.direction;
          
          // Boundary check
          const charWidth = this.getWidth();
          const minX = CONFIG.edgePadding;
          const maxX = stageWidth - charWidth - CONFIG.edgePadding;
          
          if (this.x >= maxX) {
            this.x = maxX;
            this.direction = -1;
          } else if (this.x <= minX) {
            this.x = minX;
            this.direction = 1;
          }
        }
      }
      
      /**
       * Easing functions
       */
      easeOutQuad(t) {
        return t * (2 - t);
      }
      
      // Cubic ease-in starts slower than quadratic
      easeInCubic(t) {
        return t * t * t;
      }
      
      // Quartic ease-out for smoother deceleration
      easeOutCubic(t) {
        return 1 - Math.pow(1 - t, 3);
      }

      /**
       * Render to DOM
       */
      render() {
        const col = this.currentFrame % this.config.cols;
        const row = Math.floor(this.currentFrame / this.config.cols);
        const scale = this.actualSpriteScale || this.displayScale;
        const bgX = -(col * this.config.frameWidth * scale);
        const bgY = -(row * this.config.frameHeight * scale);
        
        this.element.style.backgroundPosition = `${bgX}px ${bgY}px`;
        
        // Apply position offset based on current sprite and direction
        // Use separate offsets for each direction since sprites may be asymmetric
        const dirKey = this.direction === 1 ? 'right' : 'left';
        const baseOffset = CONFIG.spriteOffsets[dirKey][this.currentSprite] || 0;
        const finalOffset = baseOffset * this.displayScale;
        
        this.element.style.left = `${this.x + finalOffset}px`;
        
        // Flip logic:
        // - Walking/Idle: direction 1 (right) = flip, direction -1 (left) = normal
        // - Thinking: flip based on direction (sprite faces away, so flip logic is same)
        let isFlipped = false;
        if (this.direction === 1) {
          this.element.style.transform = 'scaleX(-1)';
          isFlipped = true;
        } else {
          this.element.style.transform = 'scaleX(1)';
          isFlipped = false;
        }
        
        // Counter-flip the state indicator so text is always readable
        this.stateIndicator.style.transform = isFlipped 
          ? 'translateX(-50%) scaleX(-1)' 
          : 'translateX(-50%)';
        
        this.element.style.zIndex = 10;
        
        // Update state indicator
        this.stateIndicator.textContent = this.state;
      }
    }

    // ============================================
    // LEELA CHARACTER CLASS (simple, follows Neil)
    // ============================================
    class LeelaCharacter {
      constructor(stage) {
        this.name = 'leela';
        this.config = SPRITES.leela.walk;
        this.stage = stage;
        
        this.currentFrame = 0;
        this.lastFrameTime = 0;
        this.frameInterval = 1000 / this.config.fps;
        
        this.x = 0;
        this.direction = 1;
        this.speed = CONFIG.leelaSpeed;
        
        this.displayScale = 1;
        this.referenceDisplayScale = null;
        
        // Following behavior
        this.isFollowing = false;
        this.targetX = 0;
        
        this.element = document.createElement('div');
        this.element.className = 'character sprite-leela';
        this.stage.appendChild(this.element);
      }

      setScale(scale) {
        if (this.referenceDisplayScale === null) {
          this.referenceDisplayScale = scale;
        }
        this.displayScale = scale;
        
        const width = this.config.frameWidth * scale;
        const height = this.config.frameHeight * scale;
        const sheetW = this.config.sheetWidth * scale;
        const sheetH = this.config.sheetHeight * scale;
        
        this.element.style.width = `${width}px`;
        this.element.style.height = `${height}px`;
        this.element.style.backgroundSize = `${sheetW}px ${sheetH}px`;
        
        this.render();
      }

      getWidth() {
        return this.config.frameWidth * this.displayScale;
      }

      /**
       * Update - Leela moves independently of Neil
       */
      update(currentTime, deltaTime, stageWidth) {
        // Update animation frame (always animate)
        if (currentTime - this.lastFrameTime >= this.frameInterval) {
          this.currentFrame = (this.currentFrame + 1) % this.config.totalFrames;
          this.lastFrameTime = currentTime;
        }
        
        // Leela always keeps moving independently
        const scaleRatio = this.displayScale / this.referenceDisplayScale;
        const movement = (this.speed * scaleRatio * deltaTime) / 1000;
        this.x += movement * this.direction;
        
        // Boundary check
        const charWidth = this.getWidth();
        const minX = CONFIG.edgePadding;
        const maxX = stageWidth - charWidth - CONFIG.edgePadding;
        
        if (this.x >= maxX) {
          this.x = maxX;
          this.direction = -1;
        } else if (this.x <= minX) {
          this.x = minX;
          this.direction = 1;
        }
      }

      render() {
        const col = this.currentFrame % this.config.cols;
        const row = Math.floor(this.currentFrame / this.config.cols);
        const bgX = -(col * this.config.frameWidth * this.displayScale);
        const bgY = -(row * this.config.frameHeight * this.displayScale);
        
        this.element.style.backgroundPosition = `${bgX}px ${bgY}px`;
        this.element.style.left = `${this.x}px`;
        
        if (this.direction === 1) {
          this.element.style.transform = 'scaleX(-1)';
        } else {
          this.element.style.transform = 'scaleX(1)';
        }
        
        this.element.style.zIndex = 20;
      }
    }

    // ============================================
    // SCENE MANAGER
    // ============================================
    class WalkingScene {
      constructor() {
        this.stage = document.getElementById('walkingStage');
        this.isPaused = false;
        this.scale = 0.75;
        this.lastTime = 0;
        this.animationId = null;
        
        this.playPauseBtn = document.getElementById('playPauseBtn');
        this.scaleSlider = document.getElementById('scaleSlider');
        this.scaleValue = document.getElementById('scaleValue');
        
        // Create characters
        this.neil = new NeilCharacter(this.stage);
        this.leela = new LeelaCharacter(this.stage);
        
        this.bindEvents();
        this.updateScale(this.scale);
        this.setInitialPositions();
        
        this.animationId = requestAnimationFrame((t) => this.animate(t));
      }

      setInitialPositions() {
        const stageWidth = this.stage.clientWidth || window.innerWidth;
        
        this.neil.x = CONFIG.edgePadding;
        this.neil.direction = 1;
        
        this.leela.x = stageWidth - this.leela.getWidth() - CONFIG.edgePadding;
        this.leela.direction = -1;
      }

      updateScale(newScale) {
        this.scale = newScale;
        this.neil.setScale(newScale);
        
        const neilDisplayHeight = SPRITES.neil.walk.frameHeight * newScale;
        const leelaTargetHeight = neilDisplayHeight * CONFIG.leelaHeightRatio;
        const leelaScale = leelaTargetHeight / SPRITES.leela.walk.frameHeight;
        this.leela.setScale(leelaScale);
      }

      bindEvents() {
        this.playPauseBtn.addEventListener('click', () => this.togglePlayPause());
        
        this.scaleSlider.addEventListener('input', (e) => {
          const newScale = parseFloat(e.target.value);
          this.scaleValue.textContent = `${newScale}√ó`;
          this.updateScale(newScale);
        });
        
        document.addEventListener('keydown', (e) => {
          switch (e.code) {
            case 'Space':
              e.preventDefault();
              this.togglePlayPause();
              break;
            case 'Equal':
            case 'NumpadAdd':
              e.preventDefault();
              this.adjustScale(0.05);
              break;
            case 'Minus':
            case 'NumpadSubtract':
              e.preventDefault();
              this.adjustScale(-0.05);
              break;
          }
        });
        
        window.addEventListener('resize', () => {
          const stageWidth = this.stage.clientWidth;
          const maxX = stageWidth - this.neil.getWidth() - CONFIG.edgePadding;
          if (this.neil.x > maxX) this.neil.x = maxX;
          
          const leelaMaxX = stageWidth - this.leela.getWidth() - CONFIG.edgePadding;
          if (this.leela.x > leelaMaxX) this.leela.x = leelaMaxX;
        });
      }

      togglePlayPause() {
        this.isPaused = !this.isPaused;
        this.playPauseBtn.textContent = this.isPaused ? '‚ñ∂ Play' : '‚è∏ Pause';
        this.playPauseBtn.classList.toggle('paused', this.isPaused);
        
        if (!this.isPaused) {
          this.lastTime = 0;
        }
      }

      adjustScale(delta) {
        const newScale = Math.max(0.25, Math.min(2, this.scale + delta));
        this.scale = newScale;
        this.scaleSlider.value = newScale;
        this.scaleValue.textContent = `${newScale.toFixed(2)}√ó`;
        this.updateScale(newScale);
      }

      animate(currentTime) {
        const deltaTime = this.lastTime === 0 ? 0 : currentTime - this.lastTime;
        this.lastTime = currentTime;
        
        if (!this.isPaused && deltaTime > 0) {
          const stageWidth = this.stage.clientWidth;
          
          // Update Neil
          this.neil.update(currentTime, deltaTime, stageWidth);
          
          // Update Leela independently
          this.leela.update(currentTime, deltaTime, stageWidth);
        }
        
        // Always render
        this.neil.render();
        this.leela.render();
        
        this.animationId = requestAnimationFrame((t) => this.animate(t));
      }

      destroy() {
        if (this.animationId) {
          cancelAnimationFrame(this.animationId);
        }
      }
    }

    // ============================================
    // INITIALIZE
    // ============================================
    const scene = new WalkingScene();
  </script>
</body>
</html>
